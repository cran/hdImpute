<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Philip Waggoner" />

<meta name="date" content="2023-08-07" />

<title>Getting Started</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Getting Started</h1>
<h4 class="author">Philip Waggoner</h4>
<h4 class="date">August 07, 2023</h4>



<div id="introductory-remarks" class="section level2">
<h2>Introductory Remarks</h2>
<p>This brief vignette walks users through the <code>hdImpute</code>
package at a high level, covering:</p>
<ol style="list-style-type: decimal">
<li><p>The <code>hdImpute</code> process in individual stages
(correlation matrix, flatten and rank, and impute and join)</p></li>
<li><p>The <code>hdImpute</code> process in a single stage, with minimal
arguments to satisfy via the <code>hdImpute()</code> function, which
does all three steps in a single call.</p></li>
</ol>
<p>The first approach offers users a bit more flexibility in
preprocessing and in the <code>hdImpute</code> process (e.g., storing
objects as they are created, setting up timing or benchmarking along the
way, etc.). The second approach is slightly more inflexible, but is more
intuitive. Users simply pass the raw data object (<code>data</code>) and
supply the batch size (<code>batch</code>) to the
<code>hdImpute()</code> function. The function takes care of all stages
from the first approach in a single function call.</p>
</div>
<div id="approach-1-individual-stages" class="section level2">
<h2>Approach 1: Individual Stages</h2>
<p>For the stage-based approach, there are three core functions users
must use:</p>
<ol style="list-style-type: decimal">
<li><p><code>feature_cor()</code>: creates the correlation matrix.
<em>Note</em>: Dependent on the size and dimensionality of the data as
well as the speed of the machine, this preprocessing step could take
some time. For example, in an earlier testing run, a simulated data
frame of size 20000 <span class="math inline">\(\times\)</span> 3000 had
a runtime of roughly 4.25 hours, while a smaller data frame of size 2519
<span class="math inline">\(\times\)</span> 1558 had a runtime of
roughly 1 minute on an AWS EC2 instance with 32 cores.</p></li>
<li><p><code>flatten_mat()</code>: flattens the correlation matrix from
the previous stage, and ranks the features based on absolutely
correlations. Thus, the input for <code>flatten_mat()</code> should be
the stored output from <code>feature_cor()</code>.</p></li>
<li><p><code>impute_batches()</code>: creates batches based on the
feature rankings from <code>flatten_mat()</code>, and then imputes
missing values for each batch, until all batches are completed. Then,
joins the batches to give a completed, imputed data set.</p></li>
</ol>
<p>Consider a basic example.</p>
<p>First, load the library along with the <code>tidyverse</code> library
for some additional helpers.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(hdImpute)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span></code></pre></div>
<p>Next, set up the data and introduce missingness completely at random
(MCAR) via the <code>prodNA()</code> function from the
<code>missForest</code> package.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>d <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X1 =</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>), </span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>                <span class="at">X2 =</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;A&quot;</span>, <span class="dv">3</span>), </span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>                       <span class="fu">rep</span>(<span class="st">&quot;B&quot;</span>, <span class="dv">3</span>)), </span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>                <span class="at">X3 =</span> <span class="fu">c</span>(<span class="dv">3</span><span class="sc">:</span><span class="dv">8</span>),</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>                <span class="at">X4 =</span> <span class="fu">c</span>(<span class="dv">5</span><span class="sc">:</span><span class="dv">10</span>),</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>                <span class="at">X5 =</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">&quot;A&quot;</span>, <span class="dv">3</span>), </span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>                       <span class="fu">rep</span>(<span class="st">&quot;B&quot;</span>, <span class="dv">3</span>)), </span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>                <span class="at">X6 =</span> <span class="fu">c</span>(<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">6</span>))</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1234</span>)</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>data <span class="ot">&lt;-</span> missForest<span class="sc">::</span><span class="fu">prodNA</span>(d, <span class="at">noNA =</span> <span class="fl">0.30</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>  <span class="fu">as_tibble</span>()</span></code></pre></div>
<p><em>Note</em>: This is a tiny sample set, but hopefully the usage is
clear enough.</p>
<p>Next, follow each stage mentioned above, starting with building the
correlation matrix. Of note, <code>feature_cor()</code> as an additional
argument <code>return_cor</code>, which is logical. The default is
<code>FALSE</code>, but if <code>TRUE</code>, the output is stored as
normal, and the correlation matrix is printed in the console. For
illustrative purposes, I set <code>return_cor = TRUE</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>all_cor <span class="ot">&lt;-</span> <span class="fu">feature_cor</span>(data,</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>                       <span class="at">return_cor =</span> <span class="cn">TRUE</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a><span class="co">#&gt;    X1        X2        X3        X4        X5        X6</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">#&gt; X1  1 0.0000000 1.0000000 1.0000000 0.6666667 1.0000000</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">#&gt; X2  0 1.0000000 0.9707253 0.9707253 1.0000000 0.7559289</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt; X3  1 0.9707253 1.0000000 1.0000000 0.9244735 0.3885143</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt; X4  1 0.9707253 1.0000000 1.0000000 0.9244735 0.3885143</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">#&gt; X5  0 1.0000000 0.9244735 0.9244735 1.0000000 0.3885143</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt; X6  1 0.7559289 0.4313311 0.4313311 0.6123724 1.0000000</span></span></code></pre></div>
<p>Next, flatten the matrix and order features. Similarly,
<code>flatten_mat()</code> has an optional argument
<code>return_mat</code>, which by default is set to <code>FALSE</code>.
If <code>TRUE</code>, it prints the ranked features based on the
correlation matrix. Here again, I set it to <code>TRUE</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>flat_mat <span class="ot">&lt;-</span> <span class="fu">flatten_mat</span>(all_cor,</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>                        <span class="at">return_mat =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co">#&gt; # A tibble: 15 × 3</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a><span class="co">#&gt;    row   column   cor</span></span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co">#&gt;    &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a><span class="co">#&gt;  1 X1    X3     1    </span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt;  2 X1    X4     1    </span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt;  3 X3    X4     1    </span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt;  4 X2    X5     1    </span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt;  5 X1    X6     1    </span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt;  6 X2    X3     0.971</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt;  7 X2    X4     0.971</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt;  8 X3    X5     0.924</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt;  9 X4    X5     0.924</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; 10 X2    X6     0.756</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt; 11 X1    X5     0.667</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; 12 X3    X6     0.389</span></span>
<span id="cb4-18"><a href="#cb4-18" tabindex="-1"></a><span class="co">#&gt; 13 X4    X6     0.389</span></span>
<span id="cb4-19"><a href="#cb4-19" tabindex="-1"></a><span class="co">#&gt; 14 X5    X6     0.389</span></span>
<span id="cb4-20"><a href="#cb4-20" tabindex="-1"></a><span class="co">#&gt; 15 X1    X2     0</span></span></code></pre></div>
<p>Finally, impute on a batch by batch basis, join and return the
completed data set. There are several additional argument given the
imputation model is chained random forests (built on top of
<code>missRanger</code>, which is built on top of
<code>missForest</code>). Of note, the <code>pmm_k</code> and
<code>n_trees</code> arguments allow the user to specify the number of
neighbors to search and the number of trees to used in building the
random forests, respectively. Inspect the <code>missRanger</code>
documentation for more on these if desired. The default values in
<code>impute_batches()</code> are set at <code>5</code> and
<code>15</code>, respectively. Other arguments, e.g., <code>save</code>,
if set to <code>TRUE</code> saves an <code>.RDS</code> of the list of
imputed batches to the working directory. The default is set to
<code>FALSE</code>.</p>
<p>Ultimately, users need only pass the original/raw data object
(<code>data</code>), the ranked features (<code>features</code>) from
<code>flatten_mat()</code>, and the batch size (<code>batch</code>) to
the <code>impute_batches()</code> function. The output is the completed,
imputed data set.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>imputed1 <span class="ot">&lt;-</span> <span class="fu">impute_batches</span>(<span class="at">data =</span> data,</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>                           <span class="at">features =</span> flat_mat, </span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                           <span class="at">batch =</span> <span class="dv">2</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X1</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X1</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt; iter 1:  .</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X3, X2</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X3, X2</span></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a><span class="co">#&gt; iter 1:  ..</span></span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a><span class="co">#&gt; iter 2:  ..</span></span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X4, X5</span></span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X4, X5</span></span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a><span class="co">#&gt; iter 1:  ..</span></span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a><span class="co">#&gt; iter 2:  ..</span></span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb5-27"><a href="#cb5-27" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X6</span></span>
<span id="cb5-28"><a href="#cb5-28" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X6</span></span>
<span id="cb5-29"><a href="#cb5-29" tabindex="-1"></a><span class="co">#&gt; iter 1:  .</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>imputed1</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 × 6</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#&gt;      X1 X2       X3    X4 X5       X6</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt;   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt; 1     1 B         3     5 A         6</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt; 2     1 A         4     6 A         3</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; 3     3 B         5     7 A         9</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; 4     1 B         5     7 A         4</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt; 5     1 B         7     9 B         9</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a><span class="co">#&gt; 6     3 B         8    10 B         6</span></span></code></pre></div>
<p>Compare to our synthetic <code>data</code> object:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>data</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 × 6</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#&gt;      X1 X2       X3    X4 X5       X6</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt;   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt; 1     1 &lt;NA&gt;      3     5 A         6</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; 2    NA A         4     6 A         3</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; 3     3 &lt;NA&gt;      5     7 A         9</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt; 4    NA B        NA    NA &lt;NA&gt;      4</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; 5    NA B         7     9 B        NA</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt; 6    NA B         8    10 B         6</span></span></code></pre></div>
</div>
<div id="approach-2-single-call" class="section level2">
<h2>Approach 2: Single call</h2>
<p>The alternative to the individual stages approach, which is slightly
less flexible but also simpler, is to make a single call to a single
function, <code>hdImpute()</code>. The function does everything for you.
To call this function, users need only pass the raw data object
(<code>data</code>, which must have at least one missing value) along
with specifying the batch size (<code>batch</code>) to
<code>hdImpute()</code>. The returned output is the same from calling
<code>impute_batches()</code>: a complete, imputed data set that you
would get from the individual stages approach previously covered. Users
can of course update default argument values (e.g., <code>pmm_k</code>,
<code>n_trees</code>, etc.) if so desired. But there is no need to do so
for the function to work properly.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>imputed2 <span class="ot">&lt;-</span> <span class="fu">hdImpute</span>(<span class="at">data =</span> data,</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>                     <span class="at">batch =</span> <span class="dv">2</span>)</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X1</span></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X1</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a><span class="co">#&gt; iter 1:  .</span></span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X3, X2</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X3, X2</span></span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a><span class="co">#&gt; iter 1:  ..</span></span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a><span class="co">#&gt; iter 2:  ..</span></span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X4, X5</span></span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X4, X5</span></span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a><span class="co">#&gt; iter 1:  ..</span></span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a><span class="co">#&gt; iter 2:  ..</span></span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a><span class="co">#&gt; Missing value imputation by random forests</span></span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a><span class="co">#&gt;   Variables to impute:       X6</span></span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a><span class="co">#&gt;   Variables used to impute:  X6</span></span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a><span class="co">#&gt; iter 1:  .</span></span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>imputed2</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#&gt; # A tibble: 6 × 6</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">#&gt;      X1 X2       X3    X4 X5       X6</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#&gt;   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">#&gt; 1     1 B         3     5 A         6</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt; 2     1 A         4     6 A         3</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; 3     3 B         5     7 A         9</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt; 4     1 B         5     7 A         4</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt; 5     1 B         7     9 B         9</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; 6     3 B         8    10 B         6</span></span></code></pre></div>
</div>
<div id="concluding-remarks" class="section level2">
<h2>Concluding Remarks</h2>
<p>This software is being actively developed, with many more features to
come. Wide engagement with it and collaboration is welcomed! Here’s a
sampling of how to contribute:</p>
<ul>
<li><p>Submit an <a href="https://github.com/pdwaggoner/hdImpute/issues">issue</a> reporting
a bug, requesting a feature enhancement, etc.</p></li>
<li><p>Suggest changes directly via a <a href="https://github.com/pdwaggoner/hdImpute/pulls">pull
request</a></p></li>
<li><p><a href="https://pdwaggoner.github.io/">Reach out directly</a>
with ideas if you’re uneasy with public interaction</p></li>
</ul>
<p>Thanks for using the tool. I hope its useful.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
